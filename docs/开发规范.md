# 部门树WebGL Demo开发规范

## 一、编码风格规范

### 1.1 Vue组件规范

- **组件命名**：使用PascalCase命名，如`DeptTree.vue`、`SearchPanel.vue`
- **单文件组件结构**：统一使用`<script setup>`、`<template>`、`<style scoped>`结构
- **Props定义**：使用详细的类型和默认值，必要时添加验证

  ```js
  const props = defineProps({
    treeData: {
      type: Object,
      required: true,
      validator: (value) => {
        return value && typeof value.id === 'string'
      }
    }
  })
  ```

- **事件命名**：使用kebab-case，如`node-selected`、`tree-updated`
- **样式**：使用scoped CSS，必要时使用CSS变量统一主题

### 1.2 JavaScript规范

- **语法**：使用ES6+语法，箭头函数，解构赋值等现代特性
- **异步处理**：优先使用async/await语法处理异步
- **条件语句**：优先使用三元运算符简化简单条件
- **注释**：关键逻辑必须添加注释，遵循JSDoc格式
- **模块导入**：按照Vue官方推荐方式组织import语句顺序

### 1.3 TypeScript规范 (可选)

- 为复杂数据结构定义接口
- 使用类型推导简化代码
- 为公共API提供完整类型定义

## 二、命名约定

### 2.1 通用命名

- **变量命名**：使用camelCase，名称应表明其用途
- **常量命名**：使用UPPER_SNAKE_CASE
- **私有属性/方法**：以下划线`_`开头
- **布尔值**：使用`is`、`has`、`should`等前缀

### 2.2 特定命名

- **组件实例**：树相关命名应一致，如`treeData`、`treeNode`、`treeContainer`等
- **事件处理函数**：使用`handle`前缀，如`handleNodeClick`
- **计算属性**：使用形容词或名词，描述其提供的值
- **工具函数**：使用动词开头，如`calculateLayout`、`optimizeRendering`

### 2.3 文件命名

- **组件文件**：PascalCase，如`NodeSprite.js`
- **工具类文件**：camelCase，如`quadTree.js`
- **常量/配置文件**：camelCase，如`treeConfig.js`

## 三、项目结构规范

### 3.1 目录组织

- 严格遵循项目结构文档定义的目录结构
- 不在未定义的位置创建新文件
- 新功能模块需更新项目结构文档

### 3.2 模块划分

- **组件**：遵循单一职责原则，每个组件专注于一个功能
- **工具类**：通用功能抽离为独立工具类
- **状态管理**：按业务领域划分store
- **WebWorker**：计算密集型任务放入Worker线程

## 四、WebGL/PixiJS最佳实践

### 4.1 渲染优化

- **对象池**：频繁创建销毁的对象使用对象池管理
- **纹理图集**：使用纹理图集减少绘制调用
- **精灵批处理**：使用ParticleContainer批量处理相似节点
- **按需渲染**：只渲染视口内可见节点

```js
// 示例：使用ParticleContainer批处理
const nodeContainer = new PIXI.ParticleContainer(10000, {
  position: true,
  rotation: false,
  uvs: true,
  tint: true
})
```

### 4.2 内存管理

- **资源缓存**：实现纹理和几何体缓存
- **及时释放**：不再使用的资源及时销毁
- **防止泄漏**：监控并修复内存泄漏
- **引用管理**：避免循环引用

```js
// 示例：资源清理
function cleanUp() {
  texture.destroy(true)
  sprite.destroy({ children: true, texture: true, baseTexture: true })
}
```

### 4.3 交互处理

- **事件委托**：使用事件委托减少事件监听器数量
- **节流/防抖**：对频繁触发的事件进行节流/防抖处理
- **交互状态**：明确定义和管理交互状态

## 五、性能优化指南

### 5.1 渲染性能

- **目标帧率**：稳定保持60FPS
- **渲染指标**：单帧渲染时间不超过16ms
- **图层管理**：合理分层，避免过度绘制
- **着色器优化**：自定义着色器需优化，避免分支语句

### 5.2 数据处理

- **数据结构**：选择适合操作的数据结构，如用Map存储节点查找
- **计算优化**：重计算使用缓存，考虑时间换空间
- **异步处理**：耗时计算放入WebWorker执行
- **增量处理**：大批量操作采用增量处理避免阻塞

### 5.3 监控与调优

- **性能监控**：实时监控FPS、内存占用和关键操作耗时
- **性能预算**：设定关键操作的性能预算
- **性能分析**：定期使用Chrome DevTools分析性能瓶颈
- **渐进式优化**：根据设备性能动态调整渲染质量

## 六、测试规范

### 6.1 性能测试

- **基准测试**：建立渲染性能基准，确保不退化
- **压力测试**：测试在大数据量(10万节点)下的表现
- **内存测试**：监控内存占用，检测泄漏

### 6.2 功能测试

- **交互测试**：测试所有交互功能正常工作
- **边界测试**：测试极端情况和边界条件
- **兼容性测试**：确保在主流浏览器正常工作

## 七、协作规范

### 7.1 版本控制

- **分支管理**：功能开发使用feature分支
- **提交信息**：提交信息需包含明确的修改内容描述
- **代码审查**：重要修改需经过代码审查

### 7.2 文档规范

- **代码注释**：关键逻辑必须添加注释
- **API文档**：公共API需提供详细文档
- **更新日志**：记录重要功能变更和优化

## 八、具体实现规范

### 8.1 树节点渲染

- 节点渲染统一使用NodeSprite类
- 节点布局逻辑集中在TreeLayout中处理
- 节点交互统一由InteractionManager处理

### 8.2 性能优化实践

- 实现四叉树空间索引优化碰撞检测和可见性判断
- 大数据渲染采用分批加载和虚拟滚动策略
- 复杂计算(如布局计算)放入WebWorker中异步处理

### 8.3 交互实现

- 多选功能使用SelectionManager统一管理
- 搜索高亮通过专门的SearchHighlighter处理
- 拖拽、缩放等使用pixi-viewport提供的功能

## 九、持续优化

- 定期进行性能分析与优化
- 收集用户反馈，优先解决体验问题
- 跟踪WebGL和相关库的更新，及时应用改进
